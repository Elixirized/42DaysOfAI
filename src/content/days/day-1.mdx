---
title: "Day 1: Dev Environment Setup"
description: |
  • VSCode configuration for Python 
  • Essential VSCode extensions
  • Python libraries
  • Install AI-focused libraries 
  • Introduction to Jupyter notebooks and embedding that into VSCode 
  • NOTE: Even if you are an experienced developer, you will benefit from the VSCode and AI libraries details
  • SIDEBAR: Preview of the Capstone project
  • RESOURCES: References to dive deeper on today's topics/tools.

---

import Sidebar        from '../../components/Sidebar.astro';
import Conventions from '../sidebars/doc-conventions.mdx';
import PythonVersions from '../sidebars/python-versions.mdx';
import SidebarCapstone from '../sidebars/capstone.mdx';

# Day 1: Dev Environment Setup
This is the first day of our 42 Days of AI course, where we will set up our development environment for building business web applications using Python. We will install Visual Studio Code (VSCode), configure essential extensions, and set up a virtual environment. We will also explore the Jupyter notebook interface within VSCode and create a simple web application.

## Table of Contents
1. [Install VSCode](#install-vscode) 
2. [macOS Setup](#macos-setup)
3. [Windows Setup](#windows-setup)
4. [Linux Setup](#linux-setup)
5. [Essential Libraries](#essential-libraries)
6. [Create your "Day-1" project](#creating-your-project)

---
<div style="display: flex; gap:1rem; margin:2rem 0;">
  <Sidebar>
    <Conventions />
  </Sidebar>
</div>

# Install VSCode

If you don't already have VSCode installed, go do that [here](https://code.visualstudio.com/).

## VSCode Command Palette

The Command Palette in VS Code is a powerful feature that allows you to quickly access
commands and features by typing their names. It's like a shortcut hub for all the actions
within the editor.
To open the Command Palette, you can use the keyboard shortcut:

<img src="/images/cmd+shift+p.png" alt="Three keyboard keys arranged horizontally: cmd with the command symbol, shift with an upward arrow, and P in bold. Plus signs connect the keys, illustrating the keyboard shortcut for opening the Command Palette." />

  
To open it, press Cmd+Shift+P **(or Ctrl+Shift+P on Windows/Linux)**, and start typing your command. It's
awesome because it speeds up your workflow by letting you jump to any function without
navigating through menus or remembering keyboard shortcuts.

<img src="/images/command-palette.png" alt="Screenshot of Command Palette in VSCode" />


# Install VSCode Extensions 

To make the most of your Python development experience in VSCode, you'll want to install some essential extensions. Here are a few key extensions that will enhance your workflow:

1. **Python**: This extension provides rich support for Python, including IntelliSense, linting, debugging, and code navigation. It is essential for any Python development in VSCode.

2. **Jupyter**: This extension allows you to work with Jupyter notebooks directly within VSCode. It provides a great interface for running and editing notebooks, making it easier to work with data science projects and AI models.

3. **Pylance**: This is a fast and feature-rich language server for Python, providing improved IntelliSense and type checking. It works seamlessly with the Python extension to enhance your coding experience.

4. **GitLens**: This extension supercharges the built-in Git capabilities of VSCode. It provides insights into code authorship, history, and more, making it easier to collaborate on projects

5. **Prettier - Code formatter**: This extension helps maintain consistent code formatting across your projects. It supports multiple languages, including Python, and can be configured to run automatically on save.

6. **Live Share**: This extension allows you to collaborate in real-time with others directly within VSCode. It's great for pair programming or code reviews.

7. **Docker**: If you're working with containerized applications, this extension provides support for Docker, allowing you to build, manage, and deploy containers directly from VSCode.

8. **Path Intellisense**: This extension provides autocompletion for file paths in your code, making it easier to navigate and reference files within your project.

9. **GitHub Copilot, Windsurf, Claude Code, Gemini**: These AI-powered code completion tools help you write code faster and with fewer errors by suggesting entire lines or blocks of code based on your input.

10. **Ruff**: This is a fast Python linter that helps you catch errors and enforce coding standards in your Python code. It integrates well with the Python extension and provides real-time feedback as you code.

11. **Better Comments**: This extension helps you create more readable and organized comments in your code by allowing you to categorize comments with different colors and styles. It can improve code readability and make it easier to understand the purpose of different sections of your code.

There are many more extensions available in the **VSCode** marketplace, but these are some of the most essential ones for Python development and AI projects. You can install them by searching for their names in the Extensions view **(Cmd+Shift+X on Mac or Ctrl+Shift+X on Windows/Linux)** and clicking the **Install** button.


# Install Python

Installing Python has different steps on MacOS and Windows machines, so we start with those initial steps for each platform.

## macOS Setup

### Step 1: Install Homebrew (Package Manager)
```bash
# Install Homebrew
% /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Add Homebrew to PATH (for Apple Silicon Macs)
% echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> ~/.zshrc
% source ~/.zshrc

# Verify installation
% brew --version
```

### Step 2: Install Python
```bash
# Install latest Python
% brew install python

# Verify installation
% python3 --version
% pip3 --version
```

---

## Windows Setup

### Step 1: Install Python
1. **Download Python:**
   - Go to https://python.org/downloads/
   - Download latest Python 3.x for Windows
   - **Important:** Check "Add Python to PATH" during installation


### Step 2: Install WSL
```powershell
# Run in PowerShell as Administrator
% wsl --install

# Restart computer when prompted
# Set up Ubuntu username and password
```

### Step 3: Update Ubuntu in WSL
```bash
# Update package lists
% sudo apt update && sudo apt upgrade -y

# Install essential tools
% sudo apt install -y build-essential curl git
```

### Step 4: Install Python
```bash
# Install Python and pip
% sudo apt install -y python3 python3-pip python3-venv python3-dev

# Verify installation
% python3 --version
% pip3 --version
```

### Step 5: Install Essential Packages

## Essential Libraries

### Core Web Frameworks
- **Flask**: Lightweight, flexible web framework
- **Django**: Full-featured web framework with admin interface
- **FastAPI**: Modern, fast API framework with automatic documentation
- **Streamlit**: Rapid web app development for data science

### Data Handling
- **Pandas**: Data manipulation and analysis
- **NumPy**: Numerical computing
- **SQLAlchemy**: Database ORM
- **psycopg2**: PostgreSQL adapter
- **pymongo**: MongoDB driver

### Visualization
- **Matplotlib**: Basic plotting
- **Seaborn**: Statistical visualization
- **Plotly**: Interactive visualizations
- **Bokeh**: Interactive web visualizations

### Utilities
- **Requests**: HTTP library
- **BeautifulSoup4**: Web scraping
- **python-dotenv**: Environment variable management
- **Celery**: Task queue for background jobs

---
```bash
# Upgrade pip first
% pip install --upgrade pip

# Install Jupyter and essential libraries
% pip install jupyter jupyterlab

# Install web development packages
% pip install flask django fastapi streamlit

# Install data science packages
pip install pandas numpy matplotlib seaborn plotly

# Install database packages
% pip install sqlalchemy psycopg2-binary pymongo

# Install additional utilities
% pip install requests beautifulsoup4 python-dotenv

# Save requirements
% pip freeze > requirements.txt
```

### Step 6 Install Essential Packages
```bash
# Upgrade pip
pip install --upgrade pip

# Install Jupyter and essential libraries
pip install jupyter jupyterlab

# Install web development packages
pip install flask django fastapi streamlit

# Install data science packages
pip install pandas numpy matplotlib seaborn plotly

# Install database packages
pip install sqlalchemy psycopg2-binary pymongo

# Install additional utilities
pip install requests beautifulsoup4 python-dotenv

# Save requirements
pip freeze > requirements.txt
```

---

## Linux Setup

### Step 1: Update System
```bash
# Ubuntu/Debian
% sudo apt update && sudo apt upgrade -y

# CentOS/RHEL/Fedora
% sudo dnf update -y
# or for older versions: sudo yum update -y
```

### Step 2: Install Python and Dependencies
```bash
# Ubuntu/Debian
% sudo apt install -y python3 python3-pip python3-venv python3-dev build-essential

# CentOS/RHEL/Fedora
% sudo dnf install -y python3 python3-pip python3-devel gcc gcc-c++ make
```

## Creating Your Project

We use [Poetry](https://python-poetry.org) for Python dependency and project organization/management.

## 📦 First: Install Poetry

Follow these steps to install Poetry and create/manage Python projects; they should be identical
 on **Windows, macOS, and Linux**:

### 1. Install Poetry

Run this in your terminal (PowerShell on Windows, Terminal on macOS/Linux):

```bash
% curl -sSL https://install.python-poetry.org | python3 -
```

### 2. Add Poetry to your PATH (if not already)

If `poetry` is not found after install, add it to your PATH:

* **macOS/Linux (bash/zsh)** → add to `~/.bashrc` or `~/.zshrc`:

  ```bash
  % export PATH="$HOME/.local/bin:$PATH"
  ```

* **Windows (PowerShell)** → add this to your PowerShell profile (`$PROFILE`):

  ```powershell
  % $env:Path += ";$env:APPDATA\Python\Scripts"
  ```

Then restart your terminal.

### 3. Verify Installation

```bash
% poetry --version
```

You should see the installed version number.

---
## NEXT: 📦 Create Your Project

### 1. Create/Initialize Syntax

```bash
% poetry new my_project
% cd my_project
```
This generates a standard project structure:

```
my_project/
├── pyproject.toml
├── README.md
├── src/
│   └── my_project/
│       └── __init__.py
└── tests/
   └── __init__.py
```

Now we tell Poetry to initialize our project:

```
poetry install
```

Think of **`poetry install`** as “set up my project environment.” This command:

- Reads `pyproject.toml` (and poetry.lock if present).
- Creates or updates the project’s virtual environment.
- Installs:
  - Your project itself (editable install, so imports work).
  - All declared dependencies ([tool.poetry.dependencies] and optionally dev groups as listed in our `pyproject.toml` file [more on this file below]).
- If `poetry.lock` exists → installs the exact versions recorded.
- If `poetry.lock` doesn’t exist → this resolves versions, installs them, and generates our lockfile (`poetry.lock`).

📌 Typical use cases:
- First time you create (or clone -- like cloning a remote repo) a project → **`poetry install`** to get a working virtual environment ("venv").
- Any time dependencies change in `pyproject.toml` or `poetry.lock` and you want those dependencies updated.


### 2. Configure Your Python Version (if needed)

Quick sanity check (runs Python inside Poetry’s environment in our project):

```bash
% poetry run python -V
```

Inside `pyproject.toml`, Poetry will already have guessed a Python constraint. You can edit it:

```toml
[project]
requires-python = ">=3.12"
...
```
<div style="display: flex; gap:1rem; margin:2rem 0;">
  <Sidebar>
    <PythonVersions />
  </Sidebar>
</div>

### 3. Activating our Virtual Environment

A core principle in the Python world is to isolate dependencies so that a package or library used 
by one Python project doesn't affect another Python project. This is a key 
differentiator between Python projects and projects created in most other languages and application 
frameworks. If you have experienced the "dependency Hell" of global package installations breaking 
multiple projects, you will appreciate the refreshing lack of that issue with Python projects--**if** you 
follow the convention of "virtual environments" which enable this dependency isolation.

Unlike other Python package managers (like `pip`, the default package manager for Python), Poetry 
automatically manages virtual environments for each project, and we illustrated **creating** the virtual 
environment with the **`poetry install`** command above. 

👉 You _activate_ the virtual environment with **`poetry shell`** (**WRONG!! DEPRECATED!!**) or run 
one-off commands with **`poetry run`**.

### ⚖️ `poetry run` vs `poetry shell` (**WRONG!! DEPRECATED!!**)

| Command                | What it does                                                                       | When to use it                                                                                                         | Pros                                                                                                                | Cons                                                                              |
| ---------------------- | ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **`poetry run <cmd>`** | Runs a single command inside the Poetry virtual environment (without entering it). | - Scripts & automation<br/>- CI/CD pipelines<br/>- One-off commands (`poetry run pytest`, `poetry run python script.py`) | ✅ No need to enter/exit a subshell<br/>✅ Reproducible (works in scripts)<br/>✅ Great for automation                   | ❌ Verbose (you must prefix each command)<br/>❌ Less convenient for interactive dev |
| **`poetry shell`**     | (**WRONG!! DEPRECATED!!**)                                                         | - Day-to-day dev work<br/>- When running multiple commands (`python`, `pytest`, `ipython`, etc.)                        | ✅ Natural workflow (`python`, `pytest` just work)<br/>✅ Good for interactive debugging<br/>✅ Prompt shows active venv | ❌ You must remember to `exit` when done<br/>❌ Not ideal for scripts or automation  |

---

### 🟢 Best Practice

* **Developing interactively** → `poetry shell`
* **Running one-off commands or in scripts/CI** → `poetry run <cmd>`

👉 Think of it like:

* `poetry run` = **“just run this thing inside the venv.”**
* **`poetry shell`** = **“drop me into the venv until I’m done.”**

✅ We will usually be developing interactively, so **`poetry shell`** will be our convention.

### 4. Add Dependencies

We will use Jupyter notebooks embedded in VS Code; this installs those dependencies in our project:

```
% poetry add --group dev ipykernel jupyter
```

- The `--group dev` flag specifies (in our pyproject.toml file) that these are Development-only dependencies.

This seemingly simple installation command takes our project from an empty list of installed Python libraries (via `poetry show`) to something like this:

```
anyio                     4.10.0         High-level concurrency and network...
appnope                   0.1.4          Disable App Nap on macOS >= 10.9
argon2-cffi               25.1.0         Argon2 for Python
argon2-cffi-bindings      25.1.0         Low-level CFFI bindings for Argon2
arrow                     1.3.0          Better dates & times for Python
asttokens                 3.0.0          Annotate AST trees with source cod...
async-lru                 2.0.5          Simple LRU cache for asyncio
attrs                     25.3.0         Classes Without Boilerplate
babel                     2.17.0         Internationalization utilities
beautifulsoup4            4.13.5         Screen-scraping library
bleach                    6.2.0          An easy safelist-based HTML-saniti...
certifi                   2025.8.3       Python package for providing Mozil...
cffi                      1.17.1         Foreign Function Interface for Pyt...
charset-normalizer        3.4.3          The Real First Universal Charset D...
comm                      0.2.3          Jupyter Python Comm implementation...
debugpy                   1.8.16         An implementation of the Debug Ada...
decorator                 5.2.1          Decorators for Humans
defusedxml                0.7.1          XML bomb protection for Python std...
executing                 2.2.1          Get the currently executing AST no...
fastjsonschema            2.21.2         Fastest Python implementation of J...
fqdn                      1.5.1          Validates fully-qualified domain n...
h11                       0.16.0         A pure-Python, bring-your-own-I/O ...
httpcore                  1.0.9          A minimal low-level HTTP client.
httpx                     0.28.1         The next generation HTTP client.
idna                      3.10           Internationalized Domain Names in ...
ipykernel                 6.30.1         IPython Kernel for Jupyter
ipython                   9.5.0          IPython: Productive Interactive Co...
ipython-pygments-lexers   1.1.1          Defines a variety of Pygments lexe...
ipywidgets                8.1.7          Jupyter interactive widgets
isoduration               20.11.0        Operations with ISO 8601 durations
jedi                      0.19.2         An autocompletion tool for Python ...
jinja2                    3.1.6          A very fast and expressive templat...
json5                     0.12.1         A Python implementation of the JSO...
jsonpointer               3.0.0          Identify specific nodes in a JSON ...
jsonschema                4.25.1         An implementation of JSON Schema v...
jsonschema-specifications 2025.4.1       The JSON Schema meta-schemas and v...
jupyter                   1.1.1          Jupyter metapackage. Install all t...
jupyter-client            8.6.3          Jupyter protocol implementation an...
jupyter-console           6.6.3          Jupyter terminal console
jupyter-core              5.8.1          Jupyter core package. A base packa...
jupyter-events            0.12.0         Jupyter Event System library
jupyter-lsp               2.3.0          Multi-Language Server WebSocket pr...
jupyter-server            2.17.0         The backend—i.e. core services, AP...
jupyter-server-terminals  0.5.3          A Jupyter Server Extension Providi...
jupyterlab                4.4.7          JupyterLab computational environment
jupyterlab-pygments       0.3.0          Pygments theme using JupyterLab CS...
jupyterlab-server         2.27.3         A set of server components for Jup...
jupyterlab-widgets        3.0.15         Jupyter interactive widgets for Ju...
lark                      1.2.2          a modern parsing library
markupsafe                3.0.2          Safely add untrusted strings to HT...
matplotlib-inline         0.1.7          Inline Matplotlib backend for Jupyter
mistune                   3.1.4          A sane and fast Markdown parser wi...
nbclient                  0.10.2         A client library for executing not...
nbconvert                 7.16.6         Converting Jupyter Notebooks (.ipy...
nbformat                  5.10.4         The Jupyter Notebook format
nest-asyncio              1.6.0          Patch asyncio to allow nested even...
notebook                  7.4.5          Jupyter Notebook - A web-based not...
notebook-shim             0.2.4          A shim layer for notebook traits a...
packaging                 25.0           Core utilities for Python packages
pandocfilters             1.5.1          Utilities for writing pandoc filte...
parso                     0.8.5          A Python Parser
pexpect                   4.9.0          Pexpect allows easy control of int...
platformdirs              4.4.0          A small Python package for determi...
prometheus-client         0.22.1         Python client for the Prometheus m...
prompt-toolkit            3.0.52         Library for building powerful inte...
psutil                    7.0.0          Cross-platform lib for process and...
ptyprocess                0.7.0          Run a subprocess in a pseudo terminal
pure-eval                 0.2.3          Safely evaluate AST nodes without ...
pycparser                 2.22           C parser in Python
pygments                  2.19.2         Pygments is a syntax highlighting ...
python-dateutil           2.9.0.post0    Extensions to the standard Python ...
python-json-logger        3.3.0          JSON Log Formatter for the Python ...
pyyaml                    6.0.2          YAML parser and emitter for Python
pyzmq                     27.0.2         Python bindings for 0MQ
referencing               0.36.2         JSON Referencing + Python
requests                  2.32.5         Python HTTP for Humans.
rfc3339-validator         0.1.4          A pure python RFC3339 validator
rfc3986-validator         0.1.1          Pure python rfc3986 validator
rfc3987-syntax            1.1.0          Helper functions to syntactically ...
rpds-py                   0.27.1         Python bindings to Rust's persiste...
send2trash                1.8.3          Send file to trash natively under ...
setuptools                80.9.0         Easily download, build, install, u...
six                       1.17.0         Python 2 and 3 compatibility utili...
sniffio                   1.3.1          Sniff out which async library your...
soupsieve                 2.8            A modern CSS selector implementati...
stack-data                0.6.3          Extract data from python stack fra...
terminado                 0.18.1         Tornado websocket backend for the ...
tinycss2                  1.4.0          A tiny CSS parser
tornado                   6.5.2          Tornado is a Python web framework ...
traitlets                 5.14.3         Traitlets Python configuration system
types-python-dateutil     2.9.0.20250822 Typing stubs for python-dateutil
typing-extensions         4.15.0         Backported and Experimental Type H...
uri-template              1.3.0          RFC 6570 URI Template Processor
urllib3                   2.5.0          HTTP library with thread-safe conn...
wcwidth                   0.2.13         Measures the displayed width of un...
webcolors                 24.11.1        A library for working with the col...
webencodings              0.5.1          Character encoding aliases for leg...
websocket-client          1.8.0          WebSocket client for Python with l...
widgetsnbextension        4.0.14         Jupyter interactive widgets for Ju...
```

### 5. Initialize Git (Sooner, rather than later)

First: Go create and **empty** repo in your GitHub account. In this example we are using the 
empty repo named "Day-1" in the 42DaysOfAI GitHub organization. Your "Day-1" repo will be under 
your GitHub account name.

Back to your terminal session, be sure you are in your project's root folder:

```
% cd my_project
```

Now initialize your local git repo:

```
% git init

Initialized empty Git repository in <path-to-your-project>/.git/
```
Next, we connect our local repo to our empty GitHub repo we created in the "First" step above:
```
% git remote add origin https://github.com/<your-GitHub-account-name>/Day-1.git
```
Verify that this worked:
```
% git remote -v
origin	https://github.com/<your-GitHub-account-name>/Day-1.git (fetch)
origin	https://github.com/<your-GitHub-account-name>/Day-1.git (push)

```
Now ask for the status of files in your local repo:

```
% git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	README.md         # Text is RED
	poetry.lock       # Text is RED
	pyproject.toml    # Text is RED
	src/              # Text is RED
	tests/            # Text is RED

nothing added to commit but untracked files present (use "git add" to track)
```
Tell git you want to add all the files (everything shown above) to the set files to be commited to the repo:

```
% git add .
```

Confirm that status now:
```
% git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   README.md                         # Text is now GREEN
	new file:   poetry.lock                       # Text is now GREEN
	new file:   pyproject.toml                    # Text is now GREEN
	new file:   src/my_project/__init__.py        # Text is now GREEN
	new file:   tests/__init__.py                 # Text is now GREEN
```
Now tell Git to save the current state of this project, and label it as the very first version with the commit 
comment of "Initial commit.” 

```
% git commit -m "Initial commit"
[main (root-commit) d16e626] Initial commit
 5 files changed, 2405 insertions(+)
 create mode 100644 README.md
 create mode 100644 poetry.lock
 create mode 100644 pyproject.toml
 create mode 100644 src/my_project/__init__.py
 create mode 100644 tests/__init__.py
```
Finally, send this "committed" state of our project to update our remote repo on GitHub:
```
% git push -u origin main
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 10 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (7/7), 50.16 KiB | 12.54 MiB/s, done.
Total 7 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To https://github.com/42DaysOfAI/Day-1.git
 * [new branch]      main -> main
branch 'main' set up to track 'origin/main'.
```

You can now go back to your GitHub repo page (at https://github.com/your-GitHub-account-name/Day-1, using this example) and refresh your browser. You will see somethig like this:

<img src="/images/GitHubDay-1Repo.png" alt="Our GitHub Repo" width="800" height="500" />


---

### Step 4: Install Essential Packages (**NEEDS UPDATING**)

```bash
# Upgrade pip
pip install --upgrade pip

# Install Jupyter and essential libraries
pip install jupyter jupyterlab

# Install web development packages
pip install flask django fastapi streamlit

# Install data science packages
pip install pandas numpy matplotlib seaborn plotly

# Install database packages
pip install sqlalchemy psycopg2-binary pymongo

# Install additional utilities
pip install requests beautifulsoup4 python-dotenv

# Save requirements
pip freeze > requirements.txt
```

## Day 1 Recap

Today, we set up our development environment for building business web applications using Python. 
We installed VSCode, configured essential extensions, and set up a virtual environment. 
We also explored the Jupyter notebook interface and created a simple web application, as well 
as installed essential libraries for data handling, visualization, and web development.

We learned how to create a project structure that is easy to navigate and maintain and also 
discussed best practices for managing dependencies, using virtual environments, and documenting 
our code. 

The importance of using version control with Git and keeping our requirements.txt file updated 
was discussed, and we learned how to use .env files to manage sensitive data and environment variables.

Discussing the importance of documenting our code and using comments to explain complex logic, 
we learned how to use MDX to create documentation files and how to use Jupyter notebooks to 
create interactive documentation.

This information provides a solid foundation for developing business web applications with 
Python and Jupyter Notebooks, we will discuss essential libraries across all major platforms 
in more depth in the coming days. Also, the face of **AI development changes day to day**, and 
we will be updating this as we go along.

<div style="display: flex; gap:1rem; margin:2rem 0;">
  <Sidebar>
    <SidebarCapstone />
  </Sidebar>
</div>
